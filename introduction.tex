\chapter{Introduction}



\section{Cutting-edge Web 2.0 applications}

Let's start with describing what Web 2.0 is. This term was created, by chance, by Dale Dougherty in a conference session in 2005[]. It doesn't mean any technological changes, nor design changes, even though few years later Web 2.0 was stared to be used in describing modern-looking websites, usually identified by a logo having a shadow[] or a beta/alpha badge, what it means is a change in how web is perceived. Rather than web being just about displaying text and rich media like images, Web 2.0 is all about interactive applications and collaboration. 

Best example of a web application allowing collaboration is forum software. A forum is a certain website, where users can create their profiles and participate in discussions on topics they find interesting. More or less, a forum is a virtual discussion amongst distributed people, with history of their messages being recorded. This was available even before Web 2.0, but the problem was that it was only available in a tiny percentage of websites - dedicated websites. All other websites were static and didn't allow any interaction. This wasn't good any more, with more and more websites being created every day, still users had no way to interact with them, which was something everyone wanted as that would allow to enrich the content of various websites. 

Interactions started rising with first introduction of commenting systems and later with websites allowing to contribute to content. Allowing users to comment on certain parts of ones website, being a news article or a product, allowed users to leave notes, comments or feedback, which then can be read by others, thus creating richer content, extending it further than what original author has planned, and most important - allowing users to contribute content. Later this content contribution started growing new ideas and WikiPedia was born[]. Currently one of the biggest websites in the whole world, while all content, website itself and platform is being created and maintained by volunteers. 

This was a paradigm shift in semantics of web, this report doesn't focus on that much, however Web 2.0 also "introduced" or in other words started pushing towards rich user interfaces. Rather than a website being a static page, which has links and forms linking to other pages, developers started to look for ways to make web applications behave closer to desktop applications. Which were always more responsive and functional that websites. AJAX was created - Asynchronous Javascript and XML, a collective group of technologies which utilise Javascript client-side and XmlHttpRequest (XHR) API to establish asynchronous connections to a server-side application. 

AJAX allows applications to fetch more data whenever a client site JavaScript application decides to, without a user issuing this action. This allows to update certain parts of pages without refreshing the whole application, hence a web mail application can be constantly updating Inbox's list of messages rather than user having to refresh the page to know if he got any more mail. Taken further, applications like Google Maps[] could be built, allowing to interact with a dataset bigger than would normally be consumed a user, by loading only the parts of map which are required to be visible. But since they are loaded asynchronously, with a fast-enough broadband connection, user could zoom in to a map and immediately get a higher detail map.

\section{Existing frameworks and languages}

Links is obviously not the only platform to create web applications, currently PHP, Ruby and Python are all highly popular. Java and .Net solutions are more popular in enterprise segment and they tend to solve problems in a different way, thus they are not going to be included in this report. Out of PHP, Ruby and Python, I chose to focus on two: PHP and Ruby. Python and Ruby are quite similar, both in terms of a language and what they offer in frameworks, thus I chose the more popular, Ruby. PHP is by far the most popular language when it comes to creating websites[], thus it couldn't not have been included in this report. 

PHP has a somewhat interesting story about how it became so popular. It is a dynamic language, with a syntax mixed from both Perl and C, however lacking a clear structure in syntax and development practices. It's not uncommon for developers to rate it as one of the worst languages out there[], however in 15 years of existence it rose to become the backbone of web. The reason for that is how quickly it is to learn, create a website and have it running deployed locally or on a server. That brought a lot of young developers, which then later moved to other languages or stayed with PHP. 

Some of the world's biggest websites are run powered by PHP[]. In my belief, Links is trying to solve a similar problem which is so great about starting with PHP - starting from zero and having a website running in the shortest amount of time possible. PHP solves this by having a language which is easy to develop in, doesn't take much effort to deploy and see it running, while Links aims for more of an integrated development environment, bringing all three tiers[] under one language. Roughly 5 years ago, frameworks started rising in PHP, making some of the web-specific functionality even easier, because even though PHP is mainly used for websites it is still a generic language. Thus including quite a few of Links-like behaviours. 

Ruby is also an old language, used heavily for scripting, however it rose as web-ready one, mainly because of Ruby On Rails[] framework. After RoR, short for Ruby on Rails, a few other smaller frameworks were created, however the spirit of RoR is still seen in them - creating websites in the less amount of code possible and providing simple solutions to hard problems. Sometimes that created scalability issues[], however for anything not as big as world scale applications, Ruby solutions worked great. One of the common things in Ruby community is videos like "How to create a blog application in 15 minutes"[], showing off the speed of scaffolding and code generation-powered tools. 

Both Ruby and PHP are really different languages from Links, thus the analysis of them and how that affects development of web applications, is included in one of the sections of this report. 

\section{Web and REST}

Big part of modern applications' requirements is how RESTful they are. REST[], REpresentational State Transfer, was defined in 2000 by Roy Fielding, as a style of application architecture bound by these constraints:

\begin{description}
  \item[Clientâ€“server] A uniform interface separates clients from servers, clients are not concerned with data storage and servers are not concerned with the user interface or user state, so that servers can be simpler and more scalable
  \item[Stateless] No client context is being stored on the server between requests. Each request from any client contains all of the information necessary to service the request, and any session state is held in the client
  \item[Cacheable] Clients can cache responses. Responses must therefore, implicitly or explicitly, define themselves as cacheable, or not, to prevent clients reusing stale or inappropriate data in response to further requests
  \item[Layered system] A client cannot ordinarily tell whether it is connected directly to the end server, or to an intermediary along the way
  \item[Code on demand (optional)] Servers are able temporarily to extend or customize the functionality of a client by the transfer of executable code
  \item[Uniform interface] The uniform interface between clients and servers simplifies and decouples the architecture, which enables each part to evolve independently
\end{description}

When a web application is called RESTful, it has a certain amount of resources, all identified by a global identifier, which can be manipulated over a standardized interface, and exchange representations of them in a format accepted by a client, assuming there exists one. Even though REST style doesn't define this as being HTTP-only, for our purposes, let's assume that all definitions below, are related to HTTP, the protocol web applications talk in. Web application resources would be identified by their URIs, the interface allowing to manipulate them is obviously HTTP and representations would come as different text types.

It thus expected that an interface would behave like this:

\begin{codelisting}
\begin{verbatim}
$ curl -H "Accept: application/json" -X POST -d "name=iphone&title=Iphone5" http://localhost/products
{'name':'Iphone5', 'location': 'http://localhost/products/iphone'}

$ curl -H "Accept:application/html" http://localhost/products/iphone
<html><body>Iphone5</body></html>

$ curl -H "Accept:application/xml" http://localhost/products/iphone
<product><name>Iphone5</name></product>

$ curl -H "Accept:application/json" http://localhost/products/iphone
{'name':'Iphone5'}

$ curl -H "Accept:text/plain"localhost/products/iphone
Iphone5
\end{verbatim}
\end{codelisting}

Even though a usual web application in most cases is just a website, thus it has only representation - HTML - I would expect a modern web application framework or a language to support RESTfullness, as it solves quite a lot of problems in current web state. First of all, it allows any website to become machine readable easily, just by exchanging a different representation, say XML, than the one returned to browsers. Second, the way it defines constrains for cacheability, statelessness and layered systems transparency, it makes web applications scale better, both in terms of development speed and ease and also performance. 

Most importantly, I think Hypermedia[] is crucial part of web as a whole, and for it to evolve for years to come, all web endpoints, being simple websites or machine consumable APIs, have to support it. It is not a big requirement for a certain web framework or a language, there are only two things it needs to do well - allow to expose resources identifiable by unique IDs, which should be predictable and reliable, and handle different response types, not just HTML. 

\section{Report Aims}
